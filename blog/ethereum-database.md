# 以太坊数据库

本人私下把以太坊数据库中存储的数据分为两大类

## 1. 区块, 索引及缓存数据

包括但不限于:

- `blockHeader`</br>
  区块头, 键为 `'h' + number + hash`, 值为区块头的 RLP 编码
- `blockBody`</br>
  区块体, 键为 `'b' + number + hash`, 值为区块中所有交易及叔块的 RLP 编码
- `blockReceipts`</br>
  交易收据, 键为 `'r' + number + hash`, 值为区块中所有交易执行完毕后得到的数据的 RLP 编码
- `code`</br>
  合约字节码, 键为 `'c' + codeHash`, 值为合约字节码
- `txLookup`</br>
  交易查询索引, 键为 `'l' + txHash`, 值为交易所处的区块的哈希
- `numberToHash`</br>
  通过高度查询哈希的索引, 键为 `'h' + number + 'n'`, 值为对应高度的区块的哈希</br>
  这是以太坊极为重要的一个索引, 因为他决定了 `canonical` 链
- `hashToNumber`</br>
  通过哈希查询高度的索引, 键为 `'H' + hash`, 值为对应的高度
- `headHeaderKey`</br>
  记录最后一个块的哈希的缓存, 键为 `'LastHeader'`, 值为最后一个块的哈希

这类数据在数据库中的键通常以固定的字母开头, 或者直接是一个固定的值

<details>
<summary>扩展知识: 如何根据交易哈希查询交易内容</summary>

1. 通过 `txLookup` 索引, 查询到交易所在的区块哈希
2. 通过 `hashToNumber` 索引, 查询哈希对应的高度
3. 通过高度及哈希查询 `blockBody`, 得到所有交易
4. 遍历所有交易, 并计算每个交易的哈希, 直到和要查询的交易的哈希相同

</details>

<details>
<summary>扩展知识: canonical 链</summary>

由于 PoW 算法的特性, 以太坊的链并不总是确定的, 同一时刻可能存在许多分叉的链.</br>
即使对于单独的某个以太坊客户端, 也会同时存在多个分叉, 不过他只会选出其中总难度最高的一个分叉作为当前的 `canonical` 链

比如, 区块数据为:

`哈希 {高度}[单个区块的难度](总难度)`

本地数据为:

`0x123 {100}[1](1)` -> `0x234 {101}[1](2)` -> `0x345 {102}[1](3)`

在网络上发现了一个新的分叉:

`0x123 {100}[1](1)` -> `0x234 {101}[1](2)` -> `0x456 {102}[2](4)`

客户端会发现远程分叉的总难度比本地的高, 开始同步远程分叉,</br>
他会先找到两个分叉最后一个共同祖先, 也就是`0x234 {101}[1](2)`, 然后下载区块 `0x456 {102}[2](4)`

当客户端在将新区块写入数据库时, 并不会删除 `0x234 {101}[1](2)`, 而是写入 `0x456 {102}[2](4)`, 并将</br>
`numberToHash` 索引指向 `0x456 {102}[2](4)`

这样做的目的是, 如果发现了新的分叉

`0x123 {100}[1](1)` -> `0x234 {101}[1](2)` -> `0x345 {102}[1](3)` -> `0x789 {103}[100](103)`

的话, 可以立即切换到新的分叉, 而不用下载所有新分叉上的区块

</details>

## 2. 账户树及每个账户的状态树

这类数据在数据库中的键为节点的 RLP 编码的哈希, 值为节点的 RLP 编码,</br>
没有固定的开头, 也没有规律可循
